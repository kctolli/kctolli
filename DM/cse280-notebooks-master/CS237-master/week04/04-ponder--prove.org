#+TITLE: DM1 Week 04 Ponder and Prove Assignment
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t d:(not "HINT")
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverythingNOT entitiespretty
#+SETUPFILE: ../theme-bigblow.setup
#+BEGIN: clocktable :maxlevel 2 :scope file
#+CAPTION: Clock summary at [2018-02-08 Thu 20:26]
| Headline                           |    Time |      |
|------------------------------------+---------+------|
| *Total time*                       | *12:21* |      |
|------------------------------------+---------+------|
| Exercises                          |    5:55 |      |
| \_  Read Subsection GHI through... |         | 3:43 |
| \_  MGX                            |         | 0:21 |
| \_  ECI                            |         | 0:42 |
| \_  ECT                            |         | 0:05 |
| \_  MKJ                            |         | 0:27 |
| \_  EFE                            |         | 0:06 |
| \_  MKL                            |         | 0:03 |
| \_  EFS                            |         | 0:08 |
| \_  MMC                            |         | 0:20 |
| Problems                           |    2:51 |      |
| \_  EBQ                            |         | 0:28 |
| \_  MHB                            |         | 0:12 |
| \_  MLB                            |         | 0:23 |
| \_  EKQ                            |         | 0:57 |
| \_  MON                            |         | 0:51 |
| Puzzles                            |    3:35 |      |
| \_  EJK                            |         | 1:04 |
| \_  EJU                            |         | 1:12 |
| \_  MNE                            |         | 1:19 |
#+END:

* Instructions
  See [[file:../week02/02-ponder--prove.org]]

* Exercises
** DONE Read Subsection GHI through subsubsection GHS
   CLOSED: [2018-02-07 Wed 19:25]
   :LOGBOOK:
   CLOCK: [2018-02-07 Wed 17:24]--[2018-02-07 Wed 19:12] =>  1:48
   CLOCK: [2018-02-06 Tue 16:41]--[2018-02-06 Tue 18:36] =>  1:55
   CLOCK: [2018-02-05 Mon 18:16]--[2018-02-05 Mon 18:16] =>  0:00
   :END:
** DONE MGX
   CLOSED: [2018-02-06 Tue 16:54]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 16:33]--[2018-02-06 Tue 16:54] =>  0:21
   :END:
#+begin_note
  More mapping versus looping.

  In the context of the binary-predicate/nested-quantifier code you were
  expected to write using loops, explore the following code that is implemented
  in the functional programming way (with implicit mapping):

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-all (pred x domain-y)
    (every (lambda (y) (funcall pred x y)) domain-y))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-all-for-all (pred domain-x domain-y)
    (every (lambda (x) (map-for-all pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (map-for-all-for-all '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
t

:HINT:
  - Hint :: See TKH for the context.
:END:
#+end_note
#+begin_info
  I have thoroughly explored the code above, and I understand the concepts used.
#+end_info
** DONE ECI
   CLOSED: [2018-02-06 Tue 17:36]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 16:54]--[2018-02-06 Tue 17:36] =>  0:42
   :END:
#+begin_note
  Implement the =for-some-for-some=, =for-some-for-all=, and =for-all-for-some=
  functions in a similar manner to the mapping =for-all-for-all=. Test them with
  at least three different predicates and their associated domains.
:HINT:
  - Hint :: See MGX for the context. If there is an =every= for universal
            quantification, what might be its existential counterpart function?
:END:
#+end_note
#+begin_info
#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-all (pred x domain-y)
    (every (lambda (y) (funcall pred x y)) domain-y))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-some (pred x domain-y)
    (some (lambda (y) (funcall pred x y)) domain-y))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-all-for-all (pred domain-x domain-y)
    (every (lambda (x) (map-for-all pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-some-for-some (pred domain-x domain-y)
    (some (lambda (x) (map-for-some pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-all-for-some (pred domain-x domain-y)
    (every (lambda (x) (map-for-some pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
  (defun map-for-some-for-all (pred domain-x domain-y)
    (some (lambda (x) (map-for-all pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (map-for-all-for-all '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
t

#+BEGIN_SRC emacs-lisp :results raw
  (map-for-some-for-some '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
t

#+BEGIN_SRC emacs-lisp :results raw
  (map-for-some-for-all '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
t

#+BEGIN_SRC emacs-lisp :results raw
  (map-for-all-for-some '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
t

#+end_info

** DONE ECT
   CLOSED: [2018-02-06 Tue 17:41]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 17:36]--[2018-02-06 Tue 17:41] =>  0:05
   :END:
#+begin_note
  Which of the following pairs are in the relation on the set [1 2 3 4] given by
  the mathy set description {(x, y) | x > y + 1} or by the equivalent lispy set
  membership predicate:

#+BEGIN_SRC emacs-lisp :results silent
  (defun in-the-relation (x y)
    (> x (+ y 1)))
#+END_SRC

  1. (2 1)
  2. (2 2)
  3. (2 3)
  4. (2 4)
  5. (3 1)
  6. (3 2)
  7. (4 1)
  8. (4 2)
  9. (4 3)
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
#+BEGIN_SRC python :results output
def greater(x, y):
  print(x > (y +1))
greater(2,1)
greater(2,2)
greater(2,3)
greater(2,4)
greater(3,1)
greater(3,2)
greater(4,1)
greater(4,2)
greater(4,3)
#+END_SRC

#+RESULTS:
: False
: False
: False
: False
: True
: False
: True
: True
: False

#+end_info

** DONE MKJ
   CLOSED: [2018-02-06 Tue 18:08]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 17:41]--[2018-02-06 Tue 18:08] =>  0:27
   :END:
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 1) (1 3) (2 2) (3 1)] | Yes or No? |
  |---------------------------+------------|
  | Reflexive?                |            |
  | Symmetric?                |            |
  | Antisymmetric?            |            |
  | Transitive?               |            |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  | [(1 1) (1 3) (2 2) (3 1)] | Yes or No? |
  |---------------------------+------------|
  | Reflexive?                |     No     |
  | Symmetric?                |     No     |
  | Antisymmetric?            |     No     |
  | Transitive?               |    Yes     |
#+end_info

** DONE EFE
   CLOSED: [2018-02-06 Tue 18:14]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 18:08]--[2018-02-06 Tue 18:14] =>  0:06
   :END:
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 1) (2 2) (3 1) (3 3)] | Yes or No? |
  |---------------------------+------------|
  | Reflexive?                |            |
  | Symmetric?                |            |
  | Antisymmetric?            |            |
  | Transitive?               |            |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  | [(1 1) (2 2) (3 1) (3 3)] | Yes or No? |
  |---------------------------+------------|
  | Reflexive?                |    Yes     |
  | Symmetric?                |     No     |
  | Antisymmetric?            |    Yes     |
  | Transitive?               |     No     |
#+end_info

** DONE MKL
   CLOSED: [2018-02-06 Tue 18:17]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 18:14]--[2018-02-06 Tue 18:17] =>  0:03
   :END:
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 2) (2 1) (3 3)] | Yes or No? |
  |---------------------+------------|
  | Reflexive?          |            |
  | Symmetric?          |            |
  | Antisymmetric?      |            |
  | Transitive?         |            |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  | [(1 2) (2 1) (3 3)] | Yes or No? |
  |---------------------+------------|
  | Reflexive?          |     No     |
  | Symmetric?          |     No     |
  | Antisymmetric?      |     No     |
  | Transitive?         |     No     | 
#+end_info

** DONE EFS
   CLOSED: [2018-02-06 Tue 18:25]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 18:17]--[2018-02-06 Tue 18:25] =>  0:08
   :END:
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 3) (2 3)]  | Yes or No? |
  |----------------+------------|
  | Reflexive?     |            |
  | Symmetric?     |            |
  | Antisymmetric? |            |
  | Transitive?    |            |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  | [(1 3) (2 3)]  | Yes or No? |
  |----------------+------------|
  | Reflexive?     |     No     |
  | Symmetric?     |     No     |
  | Antisymmetric? |    Yes     |
  | Transitive?    |     No     |  
#+end_info

** DONE MMC
   CLOSED: [2018-02-07 Wed 19:24]
   :LOGBOOK:
   CLOCK: [2018-02-07 Wed 19:15]--[2018-02-07 Wed 19:24] =>  0:09
   CLOCK: [2018-02-06 Tue 18:25]--[2018-02-06 Tue 18:36] =>  0:11
   :END:
#+begin_note
  Create a table like the one above with the members of the CM7 partition sets.
:HINT:
  - Hint :: Just copy/paste the table above and modify it. No need to write code
            to create the table.
:END:
#+end_note
#+begin_info
  | CM7 |  -7 |  -6 |  -5 |  -4 |  -3 |  -2 | -1 | 0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |
  |   1 | -49 | -42 | -35 | -28 | -21 | -14 | -7 | 0 |  7 | 14 | 21 | 28 | 35 | 42 | 49 |
  |   2 | -48 | -41 | -34 | -27 | -20 | -13 | -6 | 1 |  8 | 15 | 22 | 29 | 36 | 43 | 50 |
  |   3 | -47 | -40 | -33 | -26 | -19 | -12 | -5 | 2 |  9 | 16 | 23 | 30 | 37 | 44 | 51 |
  |   4 | -46 | -39 | -32 | -25 | -18 | -11 | -4 | 3 | 10 | 17 | 24 | 31 | 38 | 45 | 52 |
  |   5 | -45 | -38 | -31 | -24 | -17 | -10 | -3 | 4 | 11 | 18 | 25 | 32 | 39 | 46 | 53 |
  |   6 | -44 | -37 | -30 | -23 | -16 |  -9 | -2 | 5 | 12 | 19 | 26 | 33 | 40 | 47 | 54 |
  |   7 | -43 | -36 | -29 | -22 | -15 |  -8 | -1 | 6 | 13 | 20 | 27 | 34 | 41 | 48 | 55 |
#+end_info

* Problems
  Note: * means optional. If it\rsquo{}s not starred, it\rsquo{}s required.
** DONE EBQ
   CLOSED: [2018-02-06 Tue 19:05]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 18:37]--[2018-02-06 Tue 19:05] =>  0:28
   :END:
#+begin_note
  Here is one way to do a Cartesian product of two 3-element sets:
#+BEGIN_SRC emacs-lisp :results raw
  (let* ((A [a b c])
         (B [1 2 3]))
    (list (list 'a 1) (list 'a 2) (list 'a 3)
          (list 'b 1) (list 'b 2) (list 'b 3)
          (list 'c 1) (list 'c 2) (list 'c 3)))
#+END_SRC

: ((a 1) (a 2) (a 3) (b 1) (b 2) (b 3) (c 1) (c 2) (c 3))

  Here is a better way, that avoids hardcoding literal elements from sets =A=
  and =B=, and renders the list-of-lists result as a table:
#+BEGIN_SRC emacs-lisp
  (let* ((A [a b c])
         (B [1 2 3])
         (A0 (elt A 0))
         (A1 (elt A 1))
         (A2 (elt A 2))
         (B0 (elt B 0))
         (B1 (elt B 1))
         (B2 (elt B 2)))
    (list (list A0 B0) (list A0 B1) (list A0 B2)
          (list A1 B0) (list A1 B1) (list A1 B2)
          (list A2 B0) (list A2 B1) (list A2 B2)))
#+END_SRC

| a | 1 |
| a | 2 |
| a | 3 |
| b | 1 |
| b | 2 |
| b | 3 |
| c | 1 |
| c | 2 |
| c | 3 |

  Here is a much better way that defines a function that returns the Cartesian
  product of /three/ sets, and that also allows the sets to be of different
  sizes:
#+BEGIN_SRC emacs-lisp :results silent
  (defun cartesian-product-3 (s1 s2 s3)
    (loop for i across s1
          append (loop for j across s2
                       append (loop for k across s3
                                    collect (list i j k)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (cartesian-product-3 [a b c d] [1 2] [x y z w t])
#+END_SRC

| a | 1 | x |
| a | 1 | y |
| a | 1 | z |
| a | 1 | w |
| a | 1 | t |
| a | 2 | x |
| a | 2 | y |
| a | 2 | z |
| a | 2 | w |
| a | 2 | t |
| b | 1 | x |
| b | 1 | y |
| b | 1 | z |
| b | 1 | w |
| b | 1 | t |
| b | 2 | x |
| b | 2 | y |
| b | 2 | z |
| b | 2 | w |
| b | 2 | t |
| c | 1 | x |
| c | 1 | y |
| c | 1 | z |
| c | 1 | w |
| c | 1 | t |
| c | 2 | x |
| c | 2 | y |
| c | 2 | z |
| c | 2 | w |
| c | 2 | t |
| d | 1 | x |
| d | 1 | y |
| d | 1 | z |
| d | 1 | w |
| d | 1 | t |
| d | 2 | x |
| d | 2 | y |
| d | 2 | z |
| d | 2 | w |
| d | 2 | t |

  We can do better still. The problem is to figure out how best to generalize
  this to a Cartesian product of /n/ sets, again allowing for arbitrary sizes.
:HINT:
  - Hint :: To generalize this to /n/ any-sized sets is a hard problem. Try to
            think of an approach that appears promising. Write it up in English
            so that your ideas can perhaps be coded up later.
:END:
#+end_note
#+begin_info
#+BEGIN_SRC python :results output
import itertools
def Cartesian_Product(*args):
    for i in itertools.product(*args):
        print(i)
Cartesian_Product(["a", "b", "c", "d"], [1, 2], ["x", "y", "z", "w", "t"], ["I", "am", "awesome"])
#+END_SRC

#+RESULTS:
#+begin_example
('a', 1, 'x', 'I')
('a', 1, 'x', 'am')
('a', 1, 'x', 'awesome')
('a', 1, 'y', 'I')
('a', 1, 'y', 'am')
('a', 1, 'y', 'awesome')
('a', 1, 'z', 'I')
('a', 1, 'z', 'am')
('a', 1, 'z', 'awesome')
('a', 1, 'w', 'I')
('a', 1, 'w', 'am')
('a', 1, 'w', 'awesome')
('a', 1, 't', 'I')
('a', 1, 't', 'am')
('a', 1, 't', 'awesome')
('a', 2, 'x', 'I')
('a', 2, 'x', 'am')
('a', 2, 'x', 'awesome')
('a', 2, 'y', 'I')
('a', 2, 'y', 'am')
('a', 2, 'y', 'awesome')
('a', 2, 'z', 'I')
('a', 2, 'z', 'am')
('a', 2, 'z', 'awesome')
('a', 2, 'w', 'I')
('a', 2, 'w', 'am')
('a', 2, 'w', 'awesome')
('a', 2, 't', 'I')
('a', 2, 't', 'am')
('a', 2, 't', 'awesome')
('b', 1, 'x', 'I')
('b', 1, 'x', 'am')
('b', 1, 'x', 'awesome')
('b', 1, 'y', 'I')
('b', 1, 'y', 'am')
('b', 1, 'y', 'awesome')
('b', 1, 'z', 'I')
('b', 1, 'z', 'am')
('b', 1, 'z', 'awesome')
('b', 1, 'w', 'I')
('b', 1, 'w', 'am')
('b', 1, 'w', 'awesome')
('b', 1, 't', 'I')
('b', 1, 't', 'am')
('b', 1, 't', 'awesome')
('b', 2, 'x', 'I')
('b', 2, 'x', 'am')
('b', 2, 'x', 'awesome')
('b', 2, 'y', 'I')
('b', 2, 'y', 'am')
('b', 2, 'y', 'awesome')
('b', 2, 'z', 'I')
('b', 2, 'z', 'am')
('b', 2, 'z', 'awesome')
('b', 2, 'w', 'I')
('b', 2, 'w', 'am')
('b', 2, 'w', 'awesome')
('b', 2, 't', 'I')
('b', 2, 't', 'am')
('b', 2, 't', 'awesome')
('c', 1, 'x', 'I')
('c', 1, 'x', 'am')
('c', 1, 'x', 'awesome')
('c', 1, 'y', 'I')
('c', 1, 'y', 'am')
('c', 1, 'y', 'awesome')
('c', 1, 'z', 'I')
('c', 1, 'z', 'am')
('c', 1, 'z', 'awesome')
('c', 1, 'w', 'I')
('c', 1, 'w', 'am')
('c', 1, 'w', 'awesome')
('c', 1, 't', 'I')
('c', 1, 't', 'am')
('c', 1, 't', 'awesome')
('c', 2, 'x', 'I')
('c', 2, 'x', 'am')
('c', 2, 'x', 'awesome')
('c', 2, 'y', 'I')
('c', 2, 'y', 'am')
('c', 2, 'y', 'awesome')
('c', 2, 'z', 'I')
('c', 2, 'z', 'am')
('c', 2, 'z', 'awesome')
('c', 2, 'w', 'I')
('c', 2, 'w', 'am')
('c', 2, 'w', 'awesome')
('c', 2, 't', 'I')
('c', 2, 't', 'am')
('c', 2, 't', 'awesome')
('d', 1, 'x', 'I')
('d', 1, 'x', 'am')
('d', 1, 'x', 'awesome')
('d', 1, 'y', 'I')
('d', 1, 'y', 'am')
('d', 1, 'y', 'awesome')
('d', 1, 'z', 'I')
('d', 1, 'z', 'am')
('d', 1, 'z', 'awesome')
('d', 1, 'w', 'I')
('d', 1, 'w', 'am')
('d', 1, 'w', 'awesome')
('d', 1, 't', 'I')
('d', 1, 't', 'am')
('d', 1, 't', 'awesome')
('d', 2, 'x', 'I')
('d', 2, 'x', 'am')
('d', 2, 'x', 'awesome')
('d', 2, 'y', 'I')
('d', 2, 'y', 'am')
('d', 2, 'y', 'awesome')
('d', 2, 'z', 'I')
('d', 2, 'z', 'am')
('d', 2, 'z', 'awesome')
('d', 2, 'w', 'I')
('d', 2, 'w', 'am')
('d', 2, 'w', 'awesome')
('d', 2, 't', 'I')
('d', 2, 't', 'am')
('d', 2, 't', 'awesome')
#+end_example

I used the itertools library in python to create a function that uses unpacking and loops through all arguments sent to the function.
It prints out the Cartesian product of any amount of sets that it is given.

#+end_info

** DONE MHB
   CLOSED: [2018-02-07 Wed 17:36]
   :LOGBOOK:
   CLOCK: [2018-02-07 Wed 17:24]--[2018-02-07 Wed 17:36] =>  0:12
   :END:
#+begin_note
   From the definition of antisymmetric, show using logic that if xRy and x \ne y
   then it is false that yRx.
:HINT:
  - Hint :: The definition is a conditional, so use its contrapositive, which is
            equivalent.
:END:
#+end_note
#+begin_info
  \forall x \forall y \in X, (xRy \land yRx) \rightarrow (x = y)
Likewise,
  \forall x \forall y \in X, (xRy \land x \ne y) \rightarrow \not yRx

Essentially, if xRy and yRx, then x and y are equivalent.
Otherwise, if xRy but not yRx, then x and y are not equivalent.

source:
https://en.wikipedia.org/wiki/Antisymmetric_relation
#+end_info

** DONE MLB
   CLOSED: [2018-02-07 Wed 18:00]
   :LOGBOOK:
   CLOCK: [2018-02-07 Wed 17:37]--[2018-02-07 Wed 18:00] =>  0:23
   :END:
#+begin_note
  How many possible binary relations are there on a set with 3 elements?

  Replace the =;;...= to answer the question in the general case:
#+BEGIN_SRC emacs-lisp
  (defun number-of-binary-relations (n)
    "Computes the number of binary relations on a set with n elements."
    ;;...
    )
#+END_SRC
:HINT:
  - Hint :: How big is the Cartesian product of a set with 3 elements times
            itself? The number of possible binary relations is the number of
            subsets of that Cartesian product.
:END:
#+end_note
#+begin_info
#+BEGIN_SRC python :results output
def num_bin_rel(n):
  print(2**(n**2))
num_bin_rel(4)
#+END_SRC

#+RESULTS:
: 65536

My python code calculates the number of binary relations on a set with n elements.
#+end_info

** TODO EJE *
#+begin_note
  Study the following code and add to it your own. The =setq= chain implements a
  very simple and simplistic database of students and courses. Double check by
  just looking at it, but also write code to

  - find all students who have taken all courses, using the predicate
    =student-has-taken-course=.
  - find all courses that have been taken by all students, using the predicate
    =course-has-been-taken-by-student=.

  You will want some kind of =for-all-for-all= function that takes a predicate
  and two domains, like what you have already seen.

#+BEGIN_SRC emacs-lisp :results silent
  (setq students [1 2 3 4 5 6 7 8]
        courses [100 200 300 400]
        by-student '((1 100 200)
                     (2 100)
                     (3 100 200 300)
                     (4 100 200 300 400)
                     (5 100)
                     (6 100)
                     (7 100 200)
                     (8 100 200 300 400))
        by-course '((100 1 2 3 4 5 6 7 8)
                    (200 1 3 4 7 8)
                    (300 3 4 8)
                    (400 4 8)))

  (defun student-has-taken-course (student course)
    (not (null (member course (rest (assoc student by-student))))))

  (defun course-has-been-taken-by-student (course student)
    (not (null (member student (rest (assoc course by-course))))))
#+END_SRC
#+end_note
#+begin_info
  Your answer goes here.
#+end_info

** TODO MLU *
#+begin_note
  Add a few more records to the birthday table, and implement that table and the
  zodiac table in elisp using a vector of vectors (or list of lists). Then write
  code for answering the \ldquo{}complex join/query\rdquo what is a person\rsquo{}s Zodiac sign?
#+end_note
#+begin_info
  Your answer goes here.
#+end_info

** DONE EKQ
   CLOSED: [2018-02-08 Thu 19:05]
   :LOGBOOK:
   CLOCK: [2018-02-08 Thu 18:46]--[2018-02-08 Thu 19:05] =>  0:19
   CLOCK: [2018-02-07 Wed 19:33]--[2018-02-07 Wed 20:11] =>  0:38
   :END:
#+begin_note
  Which of the following are equivalence relations? If it is, show it has
  reflexivity, symmetry and transitivity. If not, argue for which of these three
  properties it lacks. The first four have people for their domain, the last
  four have numbers for their domain:

  1. xRy if x and y are siblings.
  2. xRy if x and y have the same parents.
  3. xRy if x and y share a common parent.
  4. xRy if x and y speak a common language.
  5. With domain English words, xRy if x shares a vowel with y.
  6. xRy if x \le y.
  7. xRy if x^2 + y^2 = 1.
  8. xRy if x + y = 42.
  9. xRy if \lceil{}x\rceil = \lfloor{}y\rfloor.
:HINT:
  - Hint :: This is a straightforward exercise in applying the definitions of
            these properties, and doing some logical thinking.
:END:
#+end_note
#+begin_info
  1. This is not an equivalence relation. One cannot be one's own sibling, thus this is not reflexive. However, it is symmetrical.
  2. This is an equivalence relation. It is reflexive, transitive and symmetrical. (x y) (y z) (x z) - True, it is transitive.
     (x y) (y x) - True, it is symmetrical. (x x) (y y) - True, it is reflexive.
  3. This is not an equivalence relation. It is not transitive. e.g. - (b m) (m s) (b s), b = half brother on mother's side, 
     m = me, s = half sister on dad's side. b and s do not necessarily share a parent, thus it is not transitive.
  4. This is not an equivalence relation. It is not transitive. e.g. - (e s) (s p) (e p), e = English, s = Spanish, p = Portuguese.
     A person that speaks English and Spanish does not necessarily speak Portuguese, thus it is not transitive.
  5. This is not an equivalence relation. It is not transitive. e.g. - (a e) (e i) (a i), a = has an a, e = has an e, i = has an i.
     A word that has an a does not necessarily have an i.
  6. This is an not equivalence relation. x \le x - True, it is reflexive. x \le y \le z, x \le z - True, it is transitive. However:
     x \le y and y \le x is not always true, thus it is not symmetrical. 
  7. This is not an equivalence relation. x does not necessarily equal y, thus x^2 + x^2 \ne 1. It is not reflexive.
  8. This is not an equivalence relation. x does not necessarily equal y, thus x + x \ne 42. It is not reflexive.
  9. This is not an equivalence relation. floor(x) \ne ceil(x), so it is not reflexive.
#+end_info

** DONE MON
   CLOSED: [2018-02-07 Wed 18:52]
   :LOGBOOK:
   CLOCK: [2018-02-07 Wed 18:01]--[2018-02-07 Wed 18:52] =>  0:51
   :END:
#+begin_note
  Give a better name to this function:
#+BEGIN_SRC emacs-lisp :results silent
  (defun do-something (m &optional n)
    (let* ((count (if (null n) 20 n))
           (bound (* count m)))
      (loop for i from 0 below m
            do (princ "[ ")
            (loop for j from (+ (- bound) i) to (+ bound i) by m
                  do (princ j)
                  (princ " "))
            (princ "]\n"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results output
  (do-something 3 5)
#+END_SRC

#+RESULTS:
: [ -15 -12 -9 -6 -3 0 3 6 9 12 15 ]
: [ -14 -11 -8 -5 -2 1 4 7 10 13 16 ]
: [ -13 -10 -7 -4 -1 2 5 8 11 14 17 ]

#+end_note
#+begin_info
  I can see that the function returns m lists. The first list contains all the multiples of m in the range -m*n to m*n. 
  The other lists are the same, but one is added to every number in the list in each proceeding list.
  Thus, the function name should be CMm (m being the input).

  I programmed this in Python as well:

#+BEGIN_SRC python :results output
def CMM(m, n=20):
    for i in range(0, int(m)):
        line = []
        for j in range(int(-n), int(n)):
            line.append(j*m+i)
        print("{}".format(line))

CMM(3, 5)
#+END_SRC

#+RESULTS:
: [-15, -12, -9, -6, -3, 0, 3, 6, 9, 12]
: [-14, -11, -8, -5, -2, 1, 4, 7, 10, 13]
: [-13, -10, -7, -4, -1, 2, 5, 8, 11, 14]

#+end_info

* Puzzles
** DONE EJK
   CLOSED: [2018-02-08 Thu 17:19]
   :LOGBOOK:
   CLOCK: [2018-02-08 Thu 17:53]--[2018-02-08 Thu 18:34] =>  0:41
   CLOCK: [2018-02-08 Thu 16:56]--[2018-02-08 Thu 17:19] =>  0:23
   :END:
#+begin_note
  Investigate the many features and benefits of the interaction between org-mode
  tables and elisp source blocks.
:HINT:
  - Hint :: Look at the answer to MLU for ideas on where to start.
:END:
#+end_note
*** Rephrase
  Research the special things emacs-lisp can do with org-mode tables.
*** Approach
  I will search through the book and through the emacs-lisp mini-primer to find these special features.
*** Solution
  In emacs-lisp, lists are rendered as org-mode tables. Appending to a list will also output the list as an org-mode table with the appended items added.
  Emacs-lisp can also directly interact with org-mode tables, and can specifically access specific locations of tables.
*** Proof
#+BEGIN_SRC emacs-lisp :results silent
  (defun fun (stuff)
    (let* ((sum (apply '+ (mapcar 'sixth stuff))))
          (list "Sum:" (format "%2.2f" sum))))
#+END_SRC  

#+tblname: table
| a | 12 | 34 | 56 | 78 | 180 |
#+tblfm: $6=$2+$3+$4+$5

#+BEGIN_SRC emacs-lisp :var stuff=table
  (fun stuff)
#+END_SRC

#+RESULTS:
| Sum: | 180.00 |

** DONE EJU
   CLOSED: [2018-02-08 Thu 15:24]
   :LOGBOOK:
   CLOCK: [2018-02-08 Thu 14:12]--[2018-02-08 Thu 15:24] =>  1:12
   :END:
#+begin_note
  Call two bitstrings equivalent if they both end in a 0 (and have length at
  least one). What CMM equivalence relation does this suggest?
:HINT:
  - Hint :: Think parity, or oddness and evenness.
:END:
#+end_note
*** Rephrase
  Which CMM equivalence relation calls two bitstrings equivalent if they both end in a 0 and have a
  length of at least one?
*** Approach 
  I will create an equivalence relation that matches the description above by exploring CMM's.
*** Solution
  The equivalence relation suggests the first row of CM10.
*** Proof
#+BEGIN_SRC python :results output
def CMM(m, n=20, lines=None):
    if not lines: 
        lines = m
    for i in range(0, int(lines)): 
        line = []
        for j in range(int(-n), int(n)):
            line.append(j*m+i)
        print("{}".format(line))

CMM(10, 5, 1)
#+END_SRC

#+RESULTS:
: [-50, -40, -30, -20, -10, 0, 10, 20, 30, 40]

** DONE MNE
   CLOSED: [2018-02-08 Thu 20:18]
   :LOGBOOK:
   CLOCK: [2018-02-08 Thu 19:52]--[2018-02-08 Thu 20:18] =>  0:26
   CLOCK: [2018-02-08 Thu 19:06]--[2018-02-08 Thu 19:35] =>  0:29
   CLOCK: [2018-02-08 Thu 17:25]--[2018-02-08 Thu 17:49] =>  0:24
   :END:
#+begin_note
  Consider the set of all bitstrings having length at least 3. Show that the
  relation on this set that says two bitstrings are related if they agree in the
  first three bits is an equivalence relation.
:HINT:
  - Hint :: Show that the three properties (Reflexive, Symmetric, Transitive)
            of an equivalence relation hold.
:END:
#+end_note
*** Rephrase
  Prove that all bitstrings of a length greater than or equal to three have an equivalence relation if the first three bits agree.
*** Approach
  I will examine a certain pair of bitstrings in the set that will prove the truth of the equivalence relation.
*** Solution
  The subset with the relation where two bitstrings agree in the first three bits is an equivalence relation. See proof.
*** Proof
(10111 101111) = (a b)
c = 10101
(a a) is True, thus the set is reflexive.
(a b) (b c) (a c) is True, thus the set is transitive.
(a b) (b a) is True, thus the set is symmetrical.
