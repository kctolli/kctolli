#+TITLE: DM1 Week 04 Prepare and Teach
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverything entitiespretty
#+SETUPFILE: ../theme-bigblow.setup
#+BEGIN: clocktable :maxlevel 2 :scope file
#+CAPTION: Clock summary at [2018-02-09 Fri 18:04]
| Headline                                 |   Time |      |
|------------------------------------------+--------+------|
| *Total time*                             | *1:50* |      |
|------------------------------------------+--------+------|
| Prepare                                  |   0:34 |      |
| \_  Answer What is True By Way of Review |        | 0:32 |
| \_  Answer What is True                  |        | 0:02 |
| Teach                                    |   1:16 |      |
| \_  Exercise Your Understanding          |        | 1:08 |
| \_  Discuss                              |        | 0:08 |
#+END:
* Instructions
  See [[file:../week00/00-ponder--prove.org]]

* Prepare
** DONE Answer What is True By Way of Review
   CLOSED: [2018-02-05 Mon 17:23]
   :LOGBOOK:
   CLOCK: [2018-02-05 Mon 16:50]--[2018-02-05 Mon 17:22] =>  0:32
   :END:
   If you can truthfully assert any of the following, you know what to do:

  - [X] I know that mathematical functions are useful abstractions of the
    process of transformation.
  - [X] I also know *why* mathematical functions are useful abstractions of the
    process of transformation.
  - [X] I know that *onto* functions are also called *surjective* functions.
  - [X] I know that *one-to-one* functions are also called *injective*
    functions.
  - [X] I know that in lisp there are no restrictions on what objects can be the
    inputs to a function (what it takes) and what objects can be the outputs of
    a function (what it gives).
  - [X] I know how many inputs a *k-ary* function has.
  - [X] I know that in formulas, variables can be /free/ or /bound/, but not
    both, and not neither.
  - [X] I know why it is *false* to say that predicates take only boolean
    variables as arguments.
  - [X] I know why it is *false* to say that quantifiers can *always* be
    modeled as loops.

** DONE Answer What is True
   CLOSED: [2018-02-05 Mon 17:25]
   :LOGBOOK:
   CLOCK: [2018-02-05 Mon 17:23]--[2018-02-05 Mon 17:25] =>  0:02
   :END:
  You know what to do:

  - [X] I pondered last week\rsquo{}s compare/contrast exercises, both code and gospel
    terms.
  - [X] For the code, this summary looks right:
    Points of Comparison:
    1. Both the C++ code and the elisp code solve the same problem in the same
       iterative fashion.
    2. Both solutions give the same answer up to fifteen decimal places.
    Points of Contrast:
    1. The compiled C++ code runs much faster (even counting compilation time)
       than the evaluated elisp code (not counting the function /definitions\rsquo{}/
       evaluation time) that is the =(calculate-limiting-radius 10000000)=
       block.
    2. The elisp code doesn\rsquo{}t need to include /five/ libraries, everything is
       built-in as part of the lisp interpreter and emacs runtime.
  - [X] For the gospel terms, I thought about the ramifications of taking
    scriptures out of context.
  - [X] I thought about how to answer a critic of the Church who claims the
    Doctrine and Covenants contradicts itself in what it names the greatest gift
    of God in section 6 verse 13 and section 14 verse 7.

* Teach
** DONE Exercise Your Understanding
   CLOSED: [2018-02-05 Mon 18:06]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 13:10]--[2018-02-06 Tue 13:45] =>  0:35
   CLOCK: [2018-02-05 Mon 17:33]--[2018-02-05 Mon 18:06] =>  0:33
   :END:
  Write elisp code that takes two same-sized vectors of one-character symbols
  and \ldquo{}shuffles\rdquo them together into one vector. For example:

#+BEGIN_SRC emacs-lisp
  (shuffle [A B C] [x y z])
#+END_SRC

#+RESULTS:
: [A x B y C z]

  The challenge? Do it without using loops!

*** Hint
  It can be done with one line of code in the body of the =shuffle= defun. This
  one line of code uses four functions, two of which take another function as an
  argument, the other two being those argument functions. The names of these
  four functions will be revealed during class.

** ANSWER:
#+BEGIN_SRC python :results output
import itertools
a, b = ["A", "B", "C"], ["x", "y", "z"]
print(list(itertools.chain.from_iterable(zip(a, b))))
#+END_SRC

#+RESULTS:
: ['A', 'x', 'B', 'y', 'C', 'z']

  | Functions to use |
  |------------------|
  | apply            |
  | vconcat          |
  | mapcar*          |
  | vector           |
#+BEGIN_SRC emacs-lisp :results raw 
  (mapcar 'documentation (mapcar 'intern (mapcar 'car fns)))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results raw
  (apply 'vconcat (mapcar* 'vector [A B C] [x y z]))
#+END_SRC

#+RESULTS:
[A x B y C z]

** DONE Discuss
   CLOSED: [2018-02-06 Tue 13:58]
   :LOGBOOK:
   CLOCK: [2018-02-06 Tue 13:50]--[2018-02-06 Tue 13:58] =>  0:08
   :END:
  In subsubsection GHS Roger Penrose is quoted. Discuss this quote with your
  neighbors (teams, groups, same as before or different), focusing on how he
  relates awareness, understanding and intelligence. Then consider the
  following:

  In Doctrine and Covenants section 93 the Lord defines some words. In
  particular, Doctrine and Covenants 93:24 defines truth as /knowledge
  of things as they are, and as they were, and as they are to come./
  Later, verse 29 equates /intelligence/ with /the light of truth/.
  Even later, in verse 36, appears the familiar saying /The glory of
  God is intelligence, or, in other words, light and truth/.

  From these marvelous revealed words, and /thinking in terms of sets/, we can
  conclude which of the following?

  - [ ] Intelligence is the intersection of light and truth.
  - [X] Intelligence is the union of light and truth.
  - [ ] Intelligence is a subset of truth, and light is the name of that subset.
  - [ ] Intelligence, light and truth are all synonymous.
