<!-- uses https://highlightjs.org/
-->
<!doctype html>
<html>

<head>
	<title>Week 02 Reading | CSE 220c</title>
	<link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
        <script type="text/javascript">
                 var codeType = "C++"
        </script>
        <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
        <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>

</head>

<body onload="fetchSource()">
	<div class="hero-image">
		<div class="hero-text">
			<h1>CSE 220c: Week 02</h1>
			<p>The Fundamentals</p>
		</div>
	</div>
	<h1>Similarities and Differences</h1>
	<h3>Shared Operators</h3>
	<p>Remember, both C++ and Python have C as an ancestor. Because of this, it is not shocking to find out that they share many of the same
		operators. These include +, -, /, *, ==, !=, &lt, &gt, etc. By going to these two sites, you can compare 
		<a href="https://www.tutorialspoint.com/python/python_basic_operators.htm">Python's list of operators</a> to 
		<a href="http://www.cplusplus.com/doc/tutorial/operators/">C++'s list of operators</a>. When you do so, 
		you will find that Python has a few that C++ does not.</p>
	<h3>C++'s missing operators</h3>
	<p>Because Python was created after C, its developers were able to add operators they had seen in other languages that made sense, to them, to include
	in Python. These are the ones you should not expect to find in C or C++:</p>
	<ul>
		<li>** - the exponentiation operator</li>
		<li>// - the floor division operator</li>
		<li>&lt&gt - an alternative to !=</li>
		<li>**= - the exponent and assign operator</li>
		<li>and - the logical and operator</li>
		<li>or - the locical or operator</li>
		<li>not - the logical not operator</li>
	</ul>
	<p>Don't get the wrong idea. Each of these behaviors can be done in C++, they will just be done a little differently. Take a look
	at Table 1 to see how.</p>
	<p>
		<table class="blueTable">
			<caption>Table 1: C Equivalents of Python Operators</caption>
			<thead>
				<tr>
					<th>Python</th>
					<th>C++</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>a**b</td><td>math.pow(a,b)</td>
				</tr>
				<tr>
					<td>a//b</td><td>math.floor(a/b)</td>
				</tr>
				<tr>
					<td>a &lt&gt b</td><td>a != b</td>
				</tr>
				<tr>
					<td>a**=b</td><td>a = math.pow(a,b)</td>
				</tr>
				<tr>
					<td>a and b</td><td>a && b</td>
				</tr>
				<tr>
					<td>a or b</td><td>a || b</td>
				</tr>
				<tr>
					<td>not(a and b)</td><td>!(a && b)</td>
				</tr>
			</tbody>
		</table>
	</p>
	<h3>Variables</h3>
	<p>In Python, a variable can hold any type of value and can change the type of value it holds. For example, this code is valid in Python.</p>
	<pre>
<code class="Python">age = 3
age = 5
age = 4.2</code>
	</pre>
	<p>C++ treats its variables differently. In C++ you not only declare the variable name, but must also declare the type of data the variable can hold.
	This is a valid C++ variable declaration that can hold an int.</p>
	<pre>
<code>int age = 3;</code>
	</pre>
	While this is valid C++ code
	<pre>
<code>int age = 3;
age = 5;</code>
	</pre>
	this is not valid.
	<pre>
<code>int age = 3;
age = "Shoshana";</code>
	</pre>
	<p>As with all things, there are pluses and minuses of requiring the type of a varable to be unchangable. One minus is you may need to declare 
	more variables. One plus is that there is no chance that the type of data in a variable will change when the code is running. 

	<h4>Some Common, Valid, C++ Variable Types</h4>
	<p>Basic Integer Types
	<ul>
		<li>short</li>
		<li>int</li>
		<li>long</li>

	</ul></p>
	<p>Basic Floating Point Types
		<ul>
			<li>float</li>
			<li>double</li>
			<li>long double</li>
		</ul>
	</p>
	<p>Boolean Types
		<ul>
			<li>bool</li>
		</ul>
	</p>
	<p>Character Types
		<ul>
			<li>char - single character</li>
			<li>char[] - array of characters</li>
			<li>std::string - a textual set of characters</li>
		</ul>
	</p>
	<section class="callout">
        <h3>Note!</h3>
        <h4>What is going on with that std:: stuff?</h4>
        <p>
        	C++ ships with a bunch of standard code already written and compiled for you. A bunch of this is in the <span class="file_name">standard library</span>. 
        	Get it? standard -> std:: &#128512;
        </p>
        <p>The string type is one of those things found in the standard library. That's why the <span class="file_name">std::</span> 
        	<a href="http://www.cplusplus.com/doc/oldtutorial/namespaces/"> namespace indicator</a> is in front 
        	of it. By putting <span class="file_name">std::</span> in front of the string type indicator, the compiler knows to look for it in the standard library.</p>
      </section>
	<p>Examples of declaring and setting these types of variables are good to see.</p>
	<p>
	<pre><code>bool am_smart = true;
short seconds_for_four_tenths_of_day = 32767;
int seconds_since_first_nevada_nuke_test = 2147483647;
long milliseconds_since_first_lizards = 9223372036854775807;


float largest_float = 340282346638528859811704183484516925440.000000;
double largest_double = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000;

char sex = 'f';
char name[5] = "Suzan";
std::string password = "235X-643!-54jnge;l1jt3;2";</code>
	</pre>
	</p>
	<p>
		Be careful. It is tempting to think, "Hey...those doubles look like they could hold bigger integers. Maybe I'll just use them." Such a thought will lead you 
		down a path you do not want to be on. Beginning programmers tend to think of floating point numbers are the same as a continuous number line. <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#680">They are not</a>. There are 
		numbers that a double can not represent. There are gaps in the floating point numbers on all computers in all languages and the larger the integer you 
		try to represent, the higher the probability that adding 1 to that number will result in the original number. This also applies floating point numbers when using variables of type double, not just integers.
	</p>
	<section class="callout">
	<h3>Note!</h3>
	<h4>What's up with all the underscores in the variable names?</h4>
	<p>
		Each language you will learn has written or unwritten rules called conventions. In this class you and I are following the naming convention used by Bjarne Stroustrup, the creator of C++ and head of the ISO international C++ standards body. According to 
		Bjarne, <a href="http://www.stroustrup.com/bs_faq2.html#Hungarian">underscores should be used for separation between the words making up names</a>. You will see this naming convention being used in the standard library containers you will see in week 4. 
	</p>
	<p>
		On the other hand, the official ISO standards body FAQ which Bjarne helps oversee makes a <a href="https://isocpp.org/wiki/faq/coding-standards#identifier-name-conventions">different statement</a>. Essentially, they say the way you write your names for things depends on your background, whether you are going to be using platform specific library functions, what your IDE generates for you automatically, and what your team mates are doing. In other words, don't sweat it. There are bigger things to think about and more important things to spend your time on. Oh...one more thing. Do what ever you boss says.
	</p>
	<p>
		In this class, we are using underscores_like_this (snake case). In your other classes it will probably be different. This is a good thing.&#128077;
	</p>
</section>


	<p>
		Another common mistake made by those new to C++ is they will accidentally assign a float or double value to an integer variable. Your compiler may  or may not warn you about this. What will happen if you do this is the float or double value will be converted into an int. All the data after the decimal point 
		will be lost. Be careful when you do this on purpose. It can lead to logic errors. You should, instead, make this conversion explicit so you won't forget you meant to do this, and those who come along later to fix bugs in your code will also know you meant to do this. The code example below shows you explicitly 
		state you meant to do this.
	</p>
<p>
	<pre><code>double age_in_years = 21.6;
/*
.
. 
.
*/
int an_age = int(age_in_years);//convert the double into an int and store the result in an int-type variable
</code>
</pre>
	</p>
	<p>
		You can also go the other direction, from int to double or float.
	</p>
<p>
	<pre><code>int length_in_feet = 6;
/*
.
. 
.
*/
double a_length = double(length_in_feet);//convert the int into a double and store the result in an double-type variable
</code>
</pre>
	</p>
	<p>
		In this case, the value stored in <span class="file_name">a_length</span> is 6.0 not 6.
	</p>
	<p>
		There is one more type you can use when you declare a variable, <span class="file_name">auto</span>. The <span class="file_name">auto</span> type is very 
		interesting. Its purpose is to let the computer decide the type instead of you. Don't misunderstand, the type is still fixed. The compiler uses 
		a process called <a href="https://www.geeksforgeeks.org/type-inference-in-c-auto-and-decltype/">type inference</a> to decide what type to assign to the 
		variable. For example, if the compiler infers a variable is a string type, you can't later assign it an int value.
	</p>
	<p>
	<pre><code>auto color = "blue"
color = 3;//this line causes a compiler error
</code>
</pre>
	</p>
	<h3>Arrays</h3>
	<h4>The Basic Way, C-type Arrays</h4>
	<p>
		As with most languages, there are two ways to define and fill an array. Being experienced with <a href="https://www.w3schools.com/python/python_arrays.asp">
			Python arrays</a>, little of this is new to you. The biggest differences are, since you are in C++, you have to declare the type of the data 
			held in the array, and use the <span class="file_name">{</span> and <span class="file_name">}</span> characters when you are declaring and filling an array all at once.
	</p>
	<p>
	<pre><code>auto names = {"sally","bob","jorge","brunhilda"};//an array of the four indicated strings
</code>
</pre>
	</p>
	<p>
		You can also create an array, and then fill it with values later.
	</p>
	<p>
	<pre><code>std::string names[4];//an array of four strings to be filled later
	names[0] = "sally";
	names[1] = "bob";
	names[2] = "jorge";
	names[3] = "brunhilda";
</code>
</pre>
	</p>
	<p>
		There are also other <a href="https://www.tutorialspoint.com/cplusplus/cpp_arrays.htm">C-type ways</a> to create an array.
	</p>

	<h4>A More Flexible Way</h4>
	<p>
		One major problem with the C-type arrays, as you can see in the basic examples above, is you have to know either the size of the array or exactly 
		what is going to be in the array when you are writing the code. C-type arrays don't have 
		any sort of <a href="https://www.journaldev.com/33185/python-add-to-array">append</a> function. But what happens if you don't know what size the array should be? 
		For example, what if the data to be put in the array is a set of your company's customers that have been pulled out of some database? You simply don't know how 
		many there will be until after your code has pulled them out. You could write your code in such a way that it has an array that, you think, will always 
		be larger than the number of customers. This approach will not only fail, because hopefully your business gets more and more customers, but creates an 
		opening for a <a href="https://en.wikipedia.org/wiki/Buffer_overflow">buffer overflow</a> security exploit. Now your application can be hacked. 
		Never a good thing. Only use the basic way of creating arrays if you know exactly how big, or small, the array needs to be. So what is this other way? It invoves the use of something very cool&hellip;pointers.
	</p>
	<h3>Pointers - keeping track of where things are</h3>
	<p>
		A pointer is a way of keeping track of where something is in RAM or in some other part of the computer. 
		Whatever that something is, a pointer will point at it. Don't make it harder than this. This is the entire concept. 
		It just keeps track of where stuff is so you can use it or modify it later. Now let's use pointers so we can have a stable variable that we can use even though 
		the array it points to can change.
	</p>
	<p>Let's say you have a set of patient name strings you have to repeatedly pull from and store to a database. And, let the action of pulling those customers' names produces not only the names, but 
		how many names there are. Also, suppose the purpose of pulling the names repeatedly is to announce who gets helped in the emergency room next at the hospital for which you work. The code below shows you C++'s original way of creating an array and storing where the just created array is. It uses a pointer.
	</p>
	<p>
	<pre><code>long number_of_names = //code to get the number from some database response
auto names = new std::string[number_of_names];//the type of the names variable is std::string* as infered by the compiler
</code>
</pre>
	</p>
	<p>
		In the above example, the <span class="file_name">*</span> type modifier is used. The variable <span class="file_name">names</span> is not a string variable. 
		Instead, it is a variable of type string pointer. The names variable is pointing at the first string in the <span class="file_name">names</span> array. C++ 
		arrays are dense arrays just like the ones in Python. This means if we know where the first element of the array is and we know how many things there are 
		in the array, we actually know where they all are since they are right next to each other. Because of this, you could print out the patients' names like this.
	</p>

	<p>
	<pre><code>long number_of_names = //code to get the number from some database response
auto names = new std::string[number_of_names];
/*
 .
 .Code here to fill the array with the names from some database, etc.
 .
 */

//print out the names
std::cout&lt;&lt;"name: "&lt;&lt;names[0]&lt;&lt;std::endl;
std::cout&lt;&lt;"name: "&lt;&lt;names[1]&lt;&lt;std::endl;
std::cout&lt;&lt;"name: "&lt;&lt;names[2]&lt;&lt;std::endl;
std::cout&lt;&lt;"name: "&lt;&lt;names[3]&lt;&lt;std::endl;
std::cout&lt;&lt;"name: "&lt;&lt;names[4]&lt;&lt;std::endl;

//Clean Up Your Mess!
delete[] names;
names = nullptr;
</code></pre></p>
<p>
	Notice the two lines of clean up at the end of this last example. If you use this old fashioned syntax for creating pointers in C++, any time you use the new keyword to create a pointer (called allocating memory in C++ speak), 
	you must call delete. If you don't you will have a <a href="https://searchwindowsserver.techtarget.com/definition/memory-leak">memory leak</a> in your code. 
	Memory leaks are REALLY BAD. Unfortuately they are easy to create in C++ and can be really hard to fix in complicated code. So&hellip;do as your mother taught you 
	and clean up your mess!
</p>
<p>
	Another good practice to follow is anytime you delete something, set all pointers to it to <span class="file_name"><a href="https://embeddedartistry.com/blog/2017/03/08/migrating-from-c-to-c-null-vs-nullptr/">nullptr</a></span>. (The <span class="file_name">nullptr</span>
	keyword is similar to, but not the same as, the None keyword in Python.) If you don't get into this habit, you will eventually create something called a zombie pointer or <a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling pointer</a>. While zombie pointers won't eat your brains, they will eat up your time and energy when you get seemingly random crashes in you application. Just say 
	no to zombie pointers. If you don't, you will eventually get a <a href="https://www.webopedia.com/TERM/U/use-after-free.html">use after free</a> crash in your code.
</p>
<p>
		You can completely avoid zombie pointers by setting ANY pointer to <span class="file_name">nullptr</span> AFTER you call delete. Order is important. Do NOT set it to nullptr before you call delete or you will have just written a memory leak into your code.
</p>
<section class="callout">
	<h3>Note!</h3>
	<h4>I'm getting tired of typing std:: all the time. Isn't there some other way?</h4>
	<p>
		Absolutely. All you have to do is put 
		<p><pre><code>using std::cout;
using std::endl;
using std::string;</code></pre></p>
		at the beginning of your file. Then, in that file, you don't have to type std:: in front of the <a href="https://cs.lmu.edu/~ray/notes/cppstandardlibrary/"> 
		standard library</a> things you've specified. The standard items you've seen, string, cout, and endl, are just  a few examples!
	</p>
</section>

	<h3>Pointers - the modern way</h3>
	<p>
		Unfortunately, the requirement to clean up your own mess, one aspect of memory management, is something that programmers and software engineers just can't seem to get right. Microsoft's own recent statements claim that <a href="https://www.zdnet.com/article/microsoft-heres-why-we-love-programming-language-rust-and-kicked-off-project-verona/"> 70% of  mission-critical defects</a> written into Microsoft's own apps and operating system by their programmers and engineers are the result of poor memory management (Google has made a <a href="https://www.zdnet.com/article/chrome-70-of-all-security-bugs-are-memory-safety-issues/">similar statement about their Chrome web browser</a>). Modern C++ has some things in it that can help with this...smart pointers.
	</p>
	<p>
		Smart pointers take care of cleaning up after you. It's kind of like having a very dedicated maid that you pay to follow you around and pick up after you. (FYI, you should never treat a maid or any other person this way. It is degrading and antithetical to what Christ teaches us via His gospel.) Instead of using old-fashioned 'raw' pointers, the array of names in the previous examples could be done using a smart pointer. Notice the application of the <span class="file_name">using</span> keyword near the top of the file.
	</p>
	<pre><code>using std::cout;
using std::endl;
using std::string;
using std::unique_ptr;

/*
 .
 .A bunch of code here
 .
 */

long number_of_names = //code to get the names number from some database response
unique_ptr&lt;string[]&gt; names(new string[number_of_names]);
/*
 .
 .Code here to fill the array with the names from some database, etc.
 .
 */

//print out the names
cout&lt;&lt;"name: "&lt;&lt;names[0]&lt;&lt;endl;
cout&lt;&lt;"name: "&lt;&lt;names[1]&lt;&lt;endl;
cout&lt;&lt;"name: "&lt;&lt;names[2]&lt;&lt;endl;
cout&lt;&lt;"name: "&lt;&lt;names[3]&lt;&lt;endl;
cout&lt;&lt;"name: "&lt;&lt;names[4]&lt;&lt;endl;
</code></pre></p>
<p>
	Did you see that there is no call to delete for the array? The unique pointer takes care of that.&#128077; You don't have to set it to nullptr either.&#128077;&#128077; unique_ptr takes care of all of this for you!&#128077;&#128077;&#128077; Also, there is no computational overhead to using unique_ptr. It doesn't use more memory or CPU cycles to do its job. So...all this safety, and no computational overhead.&#129395;&#129395;&#129395; Which method of using pointers do you like better? Yep...that's what I thought.&#128578;
</p>


<p>
	As with any well written language, spoken or computer, there is more than one way to accomplish the same thing. Here is another valid way to 
	print out the values in an array if you are using the old kinds of pointers but, remember, this type of thing is very dangerous. You will learn a safe way to do this same kind of thing in the next section of this reading.
</p>
<p>
	<pre><code>using std::cout;
using std::endl;
using std::string;
/*
 .
 .A bunch of code in your app here
 .
 */
long number_of_names = //code to get the number from some database response
string* names = new string[number_of_names];
/*
 .
 .Code here to fill the array with the names from some database, etc.
 .
 */

//print out the names
cout&lt;&lt;"name: "&lt;&lt;*names&lt;&lt;endl;
names++;
cout&lt;&lt;"name: "&lt;&lt;*names&lt;&lt;endl;
names++;
std::cout&lt;&lt;"name: "&lt;&lt;*names&lt;&lt;endl;
names++;
cout&lt;&lt;"name: "&lt;&lt;*names&lt;&lt;endl;
names++;
cout&lt;&lt;"name: "&lt;&lt;*names&lt;&lt;endl;

//Clean Up Your Mess!
names -= 4;//reset the pointer to the beginning of the array
delete[] names;
names = nullptr;
</code></pre></p>
<p>
	In the first line of code where a name is being printed out, you are going to see the <span class="file_name">*</span> character again. This time, 
	it isn't being used as a type modifier. Instead, it is an <a href="https://www.geeksforgeeks.org/operator-overloading-c/">overloaded operator</a> 
	that has as its input the pointer and as its output the value of the thing being pointer at. That's why, when this code is run, the names get 
	printed out instead of the pointer to the name.
</p>
<p> 
	You'll also notice that in this case, the <span class="file_name">++</span> and <span class="file_name">-=</span> operators are used directly on the pointer. These 
	are also overloaded operators. When <span class="file_name">++</span> works on a pointer, it moves the pointer to the next string in the array. It can do this 
	since the compiler it 'knows' the array holds strings, therefore it knows how far to move the pointer to get to the next string. That's exactly what the overloaded ++ operator does on any kind of pointer, be it an array of strings, doubles, floats, ints, or anything else.
</p>
<p>
	The <span class="">-=</span> operator is also overloaded. It moves the pointer backwards by some integer amount.
</p>
<p>"But wait a minute. Does that mean + and - are also overwritten?" Excellent question...yep. Stroustrup, however, does say <a href="https://www.amazon.com/Tour-2nd-Depth-Bjarne-Stroustrup/dp/0134997832/ref=sr_1_1?dchild=1&keywords=a+tour+of+c%2B%2B&qid=1594060107&sr=8-1">that being new to C++ you should never write code like the example you just saw</a>. These overloaded operators for pointers are for the use of the wise and highly experienced.</p>




<section class="callout">
	<h3>Note!</h3>
	<h4>My application is crashing!!&#128560; Why?</h4>
	<p>
		If you application crashes the odds are very high you have abused your memory management privileges. You might be deleting something more times than you 
		should. Remember, with the old methodology, one new requires one and only one delete. It's also possible you created a zombie pointer, or you may have used up all the memory available for the 
		application by creating a memory leak, or you may have set a variable to <span class="file_name">nullptr</span> and tried to use it anyway. All but the last of these problems go away if you use modern smart pointers.
	</p>
	<p>
		Remember, if your C++ app crashes, the first thing to look for are memory issues.
	</p>
	<p>
		One last thing about these C-style arrays you've been using. Don't fall in love with them. In week 04 you will learn much better and safer ways to store data in a 
		C++ way. That doesn't mean you don't need to recognize the C-style arrays. You will see them in a lot of older code and will need to know how they work and 
		what can go wrong with them. Then you will be able to fix the problem and, where possible, replace them with the C++ alternatives.
	</p>
</section>

	<h3>Let's Get Loopy!&#129322;</h3>

	<p>
		From your previous experience with programming languages, it has probably occured to you that accessing all values in an array using hardcoded numbers is 
		not a good approach. Instead loops are the way to go. C++ has several loops to choose between.
	</p>


<h4>The Logical Loop</h4>
	<p>
		In C++, the logical loop uses a variation of the while syntax found in many languages. Here is one way you could do the names example 
		using a logicial loop.
	</p>
<p>
	<pre><code>using std::cout;
using std::endl;
using std::string;
using std::unique_ptr;
/*
 .
 .A bunch of code in your app here
 .
 */
long number_of_names = //code to get the number from some database response
unique_ptr&lt;string[]&gt; names(new string[number_of_names]);
/*
 .
 .Code here to fill the array with the names from some database, etc.
 .
 */
long count_down_index = number_of_names - 1;
        
while (count_down_index >= 0) {
    cout&lt;&lt;"while name: "&lt;&lt;names[count_down_index]&lt;&lt;endl;
    count_down_index--;
}
</code></pre></p>

	<h4>The Logical Loop's Ugly Alternative</h4>
	<p>
		OK...there are those that love the the alternative to C++'s while loop that is known as 'the do statement.' I, the author, was taught to avoid it like the plague 
		when I was first learning C++. I empathize with those who love it. I don't love it. My experience agrees with what Bjarne Stroustrup wrote about in his seminal book. 
		<blockquote>In my experience, the do-statement is a source of errors and confusion. The reason is that its body is always executed once before the condition is evaluated. However, for the body to work correctly, something very much like the condition must hold even the first time through. More often than I would have guessed, I have found that condition not to hold as expected either when the program was first written and tested or later after the code preceding it has been modified. I also prefer the condition "up front where I can see it." Consequently, I tend to avoid do-statements.</blockquote>
		<span class="citation">Excerpt From: <a href="https://books.google.com/books?id=PSUNAAAAQBAJ&pg=PA236&lpg=PA236&dq=%22In+my+experience,+the+do-statement+is+a+source+of+errors+and+confusion.+The+reason+is+that+its+body+is+always+executed+once+before+the+condition+is+evaluated.+However,+for+the+body+to+work+correctly,+something+very+much+like+the+condition+must+hold+even+the+first+time+through.+More+often+then+a+would+have+guessed,+I+have+found+that+condition+not+to+hold+as+expected+either+when+the+program+was+first+written+and+tested+or+later+after+the+code+preceding+it+has+been+modified.+I+also+prefer+the+condition+%22up+front+where+I+can+see+it.%22+Consequently,+I+tend+to+avoid+do-statements.%22&source=bl&ots=DrzsEe8Y9H&sig=ACfU3U0XVl5mJvmAqxOnNeQoYWtpKSIjxQ&hl=en&sa=X&ved=2ahUKEwi9z4fejozpAhXRLs0KHfZ2CY0Q6AEwAHoECAsQAQ#v=onepage&q=%22In%20my%20experience%2C%20the%20do-statement%20is%20a%20source%20of%20errors%20and%20confusion.%20The%20reason%20is%20that%20its%20body%20is%20always%20executed%20once%20before%20the%20condition%20is%20evaluated.%20However%2C%20for%20the%20body%20to%20work%20correctly%2C%20something%20very%20much%20like%20the%20condition%20must%20hold%20even%20the%20first%20time%20through.%20More%20often%20then%20a%20would%20have%20guessed%2C%20I%20have%20found%20that%20condition%20not%20to%20hold%20as%20expected%20either%20when%20the%20program%20was%20first%20written%20and%20tested%20or%20later%20after%20the%20code%20preceding%20it%20has%20been%20modified.%20I%20also%20prefer%20the%20condition%20%22up%20front%20where%20I%20can%20see%20it.%22%20Consequently%2C%20I%20tend%20to%20avoid%20do-statements.%22&f=false"">"The C++ Programming Language"</a> Bjarne Stroustrup, Addison-Wesley &copy;2013.</span>
	</p>
	<h4>Map, Filter, Reduce, and For Each - looping's better, safer ways</h4>

		<p>
			In C++, as in most other languages, it is important not to write code that duplicates fundamental parts of the standard language library. While it is possible to write a loop in C++ to average, modify, or select some elements of an array, you should not. Instead you should use the built-in <span class="file_name">filter</span> (select some), <span class="file_name">reduce</span> (average, sum, product, etc.), or <span class="file_name">map</span> (convert all) functionality.
		</p>
      <p>
        Consider a situation where you have been hired to write code for a
        social media site. You have been asked to write code to count up the
        total number of 'likes' postings from a single customer has received.
        Existing code that others have written puts a likes count for each
        posting in an array called 'likes' for you. The code they wrote looks something like this.
      </p>
      <p>
      	<pre>
<code class="C++">#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;numeric&gt;

/*
 .
 .A bunch of code in your app here
 .
 */
long likes_count = //code to get the number from some database response
unique_ptr&lt;int[]&gt; likes(new int[likes_count]);
auto likes_end = likes.get()+likes_count;
//some code here to fill the array with values from the database response
}</code>
</pre>
      </p>
      <p>
		  Note that in the above code, <span class="file_name">likes.get()</span> provides us with access to the beginning of the array.
		</p>
		<p>
		  Suppose you were told to write code that filtered out likes that are less
        than 10. What's a good way to approach solving this problem?
      </p>
      <p>Use filter functionality. In C++, this is in the <a href="https://www.geeksforgeeks.org/stdremove-stdremove_if-c/"><span class="file_name">remove_if</span> function</a> of the standard algorithm library. Did you notice the <span class="file_name">#include</span> statement in the code snippet above? &#128578;</p>
 	  <p>
      <pre>
<code class="JavaScript">likes_end = remove_if(likes.get(), likes_end, [](auto a_likes_amount){
        return a_likes_amount < 10;
    });
}</code>
	</pre>
	  </p>
	  <p>
	  	The <span class="file_name">remove_if</span> function has three parameters, the beginning of the array, the end of the array, and a lambda that compares each element of the array to something of your choice and returns the result of that comparison. In contrast to the filtering behavior in many other languages, <span class="file_name">remove_if</span> does NOT return a filtered result. Instead, it copies all elements that do not match the condition (remember this is a <span class="file_name">remove_if</span> filter) in the lambda into the front the array and returns an indicator of where the end of the filtered part of the array is. That means that the elements in the array past the updated value (look at the assignment in the code snippet) of <span class="file_name">likes_end</span> are garbage. There's a bunch of elements still out there beyond the new value of <span class="file_name">likes_end</span>, but they are meaningless.
	  </p>
      <p>
        Let's break up the syntax for the C++ lambda function being used. It starts with two operators <span class="file_name">[</span>, and <span class="file_name">]</span>. Between these two operators, you include any variables whose values you want to capture from the enclosing scope. In this case there are none, so <span class="file_name">[]</span> is empty. The lambda required for <span class="file_name">remove_if</span> has one required parameter. Its type must match the type of the elements in the array, <span class="file_name">auto</span> takes care of this for us, and the parameter's value is each element of the array in turn. The body of the lambda function is in the <span class="file_name">{}</span> scope operators, and in this case, consists of just one line of code where the result of comparing each array element to 10 is returned.
      </p>

      <p>
        Now that you've accomplished this task, your boss asks you to write code that, instead of filtering out likes, gives the customer five
        'bonus likes' that are to be added to each posting.
      </p>

      <p>
      	What's the approach for this problem? Use map functionality, C++'s standard <a href="https://www.fluentcpp.com/2017/02/13/transform-central-algorithm/"><span class="file_name">transform</span></a> function. The code looks like this.
      </p>
      <pre>
<code class="JavaScript">likes_end = transform(likes.get(), likes_end, likes.get(), [](auto a_likes_amount){
        return a_likes_amount + 5;
    });
</code>
	</pre>
	  <p>
	  	The <span class="file_name">transform</span> function has four parameters instead of just three. The additional parameter is the third, right before the lambda. It indicates to the function where the first result should be put back into the array. In this case, the beginning of the array is used and each subsequent result is placed in the next position. So, if the array consisted of <span class="file_name">{1,3,15,7,23}</span>, the array would be transformed to be <span class="file_name">{6,9,21,13,28}</span>. See? Each element had 5 added to it and the transformed value was put in the array where the un-transformed value was.
	  </p>
      <p>
        Maybe you are asked to total the customers' likes instead of filtering or mapping them. Then you should use reduce behavior, C++'s standard <a href="https://stackoverflow.com/questions/12633950/understanding-stdaccumulate"><span class="file_name">accumulate</span> function</a>. 
      </p>
      <p>
      <pre>
<code class="JavaScript">auto total = accumulate(likes.get(), likes_end, 0, [](auto accumulator, auto a_likes_amount){
        return accumulator + a_likes_amount;
    });
</code>
	</pre>
	   </p>
    	The <span class="file_name">accumulate</span> function also has four parameters. The first the beginning of the array to total, the second is the end, the third is the accumulator's initial value, and the fourth is the lambda that returns the partial accumulated value. For this case the final result is the summation of the likes which the <span class="file_name">accumulate</span> function returns.
      </p>
      <p>
        But what if you are asked to do something more real? Something like you are to give five bonus likes only for those that already
        have 10 likes and then sum the result? The solution uses
        map, filter, and reduce behaviors together.
      </p>
      <p><pre>
<code class="JavaScript">
    likes_end = remove_if(likes.get(), likes_end, [](auto a_like_count){
        return a_like_count < 10;
    });
    
    likes_end = transform(likes.get(), likes_end, likes.get(), [](int a_likes_amount){
        return a_likes_amount + 5;
    });
    
    auto total = accumulate(likes.get(), likes_end, 0, [](auto accumulator, auto a_likes_amount){
        return accumulator + a_likes_amount;
    });
</code>
	</pre></p>
		<p>
			If you just can't get map, filter, and reduce to work for you in any combination, there is a fallback option. The <span class="file_name">for_each</span> function. Like it does in other languages, <span class="file_name">for_each</span> iterates over each element in the array, hands it to you in a lambda, and says, "Do what you want!" If you were going to use <span class="file_name">for_each</span> to print out everything in the original array of likes to the console (something you are very unlikely to do in a real app), the code would look like this.
		</p>
		<p>
      <pre>
<code class="JavaScript">for_each(likes.get(), likes_end, [](auto a_likes_amount){
        cout&lt;&lt;a_likes_amount&lt;&lt;endl;
    });
</code>
	</pre>

		<p>
			But map, filter, and reduce aren't the only algorithms you are limited to. C++ has a <a href="https://www.youtube.com/watch?v=2olsGf6JIkU">large number of others in the standard library</a> you can use in your code. Nor are you limited to using arrays. There are a whole host of different kinds of data containers in C++ <a href="https://en.cppreference.com/w/cpp/container">containers library</a>, sometimes coloquially known as the STL library, that the algorithms library functions work on.
		</p>
	<h4>The Counting Loop - Welcome to the Past!</h4>
	<p>
		In older C++ code it can be common to see C-types of constructs &#128531;. C++ has been and is moving away from these kinds of things, but you will see them. Counting loops are one type of those C-type constructs.
	</p>
	<p>
		Since C-type arrays have a fixed size and a way to access values using the [] operator, the counting loop is the C-type way to iterate over the elements of C-type arrays, but here is a very good piece of advice. Don't get too caught up in the counting loops you are about to see. In fact, you should have 
		no raw loops in your code. If this statement bothers you greatly, watch the vido <a href="https://www.youtube.com/watch?v=W2tWOdzgXHA">GoingNative 2013 C++ Seasoning Conference session</a>. It is quite long and very technical. Be warned. If you want a more accessable presentation on this topic, check out <a href="https://developer.apple.com/videos/play/wwdc2018/223">Dave Abraham's take</a>. Dave's code examples aren't in C++, but everything he says applies to C++ as well. It is a re-working of much of the material presented at the GoingNative 2013 C++ conference.
	</p>
	<p>
		The traditional, forward-iteration C-type loop always has the same parts, labeled 1, 2, 3, 4, and 5 in the code snippet below (glance down and take a look). The keyword <span class="file_name">for</span> is labeled 1 and is always followed by a set of statements, 2, 3, and 4, inside the () operator. Item 2 is a statement that declares and 
		initializes a variable traditionally called i, short for index. This is the variable that will be used to, later, access the elements of the array to retrieve or modify them. This operation is executed ONLY the first time the loop's code executes.
	</p>
	<p>
		Item 4, below, increases the value of <span class="file_name">i</span> by one. This is no suprise, but it may be a little suprising that this statement 
		isn't executed the first time the <span class="file_name">for</span> loop executes. Instead, it is exectued every time except the first time. Items 
		3 and 4 both execute every time, but when item 4 is executed it will always be executed BEFORE item 3. Wow...that's confusing. Read that again. Think through it as see what the implications are for the example below.
	</p>
	<p>
		Item 3 is a boolean check. As with most loops in most languages, if the check returns 
		<span class="file_name">false</span>, the loop terminates and the next line of code after the loop is executed.
	</p>
	<p>
		Item 5 is a set of lines of codes executed every time the item 3 check returns true
	</p>

	<p><pre><code>
 1       2        3     4
for (int i = 0; i < 7; i++){
       .
       . 5
       .
}
<span class="citation">Excerpt From: <a href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewBook?id=1023155821">"Doing Stuff With C."</a> Lee S. Barney, &copy;2015. Available on Apple Books. </span>
</code></pre></p>
<p>
	So recapping, the first time the line of code is executed, only items 2 and 3 are executed. Each time after that, 4 is executed, then three is executed, and then if 3 is 
	true, 5 executes.
</p>
<p>
	An example using the customer names example you saw before is in order. That way you can see how the counting loop replaces the ridiculous 
	set of <span class="file_name">cout</span> lines of code with just one, as you would expect.
</p>

	<p>
	<pre><code>using std::cout;
using std::endl;
using std::string;
using std::unique_ptr;
/*
 .
 .A bunch of code in your app here
 .
 */
long number_of_names = //code to get the number from some database response
unique_ptr&lt;string[]&gt; names(new string[5]);
/*
 .
 .Code here to fill the array with the names from some database, etc.
 .
 */

//print out the names
for(int i = 0; i < number_of_names; i++){
	cout&lt;&lt;"name: "&lt;&lt;names[i]&lt;&lt;endl;
}
</code></pre></p>
<p>
	There is another variant of the counting loop. It's the count down loop. You use this when you want to go in the reverse order. Since dense arrays are 
	zero indexed, you have to set the inital value of <span class="file_name">i</span> to be one less than some might expect. Here's our example re-worked 
	to use a count down loop.
</p>

	<p>
	<pre><code>using std::cout;
using std::endl;
using std::string;
using std::unique_ptr;
/*
 .
 .A bunch of code in your app here
 .
 */
long number_of_names = //code to get the number from some database response
unique_ptr&lt;string[]&gt; names(new string[5]);
/*
 .
 .Code here to fill the array with the names from some database, etc.
 .
 */

//print out the names
for(int i = number_of_names-1; i >= 0; i--){
	cout&lt;&lt;"name: "&lt;&lt;names[i]&lt;&lt;endl;
}
</code></pre></p>



	<h3>Making Choices</h3>
	<p>
		 Many, but not all, programming languages use variations of the keywords if - else_if - else to indicate choice making ('conditional branching' is the computer sciencey term) within applications. C++ is one of the 
		 languages that does. A common, traditional example of the use of this set of keywords is a number guessing game. The example strips away all extranious 
		 thinking and allows the reader to focus on the concept and syntax of code-branching in C++.
	</p>
	<p>
	<pre><code>#include &lt;iostream&gt;

using std::cout;
using std::cin;
using std::endl;

int main(int argc, const char * argv[]) {
	int secretNumber = rand()%(100 + 1);
	cout&lt;&lt;"Guess a number between 0 and 100."&lt;&lt;endl;
	int aGuess = -1;
	cin&gt;&gtaGuess;
	if (aGuess < secretNumber) {
	    cout&lt;&lt;"To low."&lt;&lt;endl;
	}
	else if (aGuess > secretNumber){
	    cout&lt;&lt;"To high."&lt;&lt;endl;
	}
	else{
	    cout&lt;&lt;"You guessed correctly!!!"&lt;&lt;endl;
	}
}
</code></pre></p>
<p>
	You'll see something new in this guessing game example, <span class="file_name">cin&gt;&gt;</span>. Using <span class="file_name">cin&gt;&gt;</span> is how you read a value from the command line into an 
	application. The type being read in is determined by the type of variable being 'filled' with a value. This is another type of user interaction you will rarely ever write in a real app.
</p>
	<h3>Loopy Choices</h3>
	<p>
		So the previous example is a little ridiculous. You only get one chance to guess. Here is one way you can combine looping and code branching so the user can guess an infinite number of times or until they guess correctly.
	</p>
		<pre><code>#include &lt;iostream&gt;

using std::cout;
using std::cin;
using std::endl;

int main(int argc, const char * argv[]) {
	int secretNumber = rand()%(100 + 1);
	while(true){}
		cout&lt;&lt;"Guess a number between 0 and 100."&lt;&lt;endl;
		int aGuess = -1;
		cin&gt;&gtaGuess;
		if (aGuess < secretNumber) {
		    cout&lt;&lt;"To low."&lt;&lt;endl;
		}
		else if (aGuess > secretNumber){
		    cout&lt;&lt;"To high."&lt;&lt;endl;
		}
		else{
		    cout&lt;&lt;"You guessed correctly!!!"&lt;&lt;endl;
		    break;
		}
	}
}
</code></pre></p>

</section>
	<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</body>
</html>
