<!-- uses https://highlightjs.org/
-->

<html>

<head>
	<link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
        <script type="text/javascript">
                 var codeType = "C++"
        </script>
        <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
        <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>
	

</head>

<body onload="fetchSource()">
<div class="hero-image">
  <div class="hero-text">
    <h1>CSE 220c: Week 05</h1>
    <p>Inside Containers</p>
  </div>
</div>
	<h1>Hidden Arrays</h1>
	<p>
		Many of the standard containers, array, vector stack, queue, etc., are actually classes that have a private C-type array as a property. Algorithms are then turned into code, instance functions of the class, to make the use of the C-type array MUCH safer. These methods have been tested, enhanced, fixed, and optimized for decades. That's why it is so much safer to use a standard container that wraps a C-type array than to use one directly. If you are ever tempted to use a C-type array, you should probably use the std::array instead. It adds almost no overhead.
	</p>
	<p>
		But sometimes, arrays are either too restrictive or the code to manipulate to match the need becomes way to complicated and slow. Here is an image of a structure known as a <a href="https://www.youtube.com/watch?v=qH6yxkw0u78">tree</a>.
	</p>
	<img src="images/tree.png" alt="A tree with root D, branches B and G, and leaves A, C in branch B, and E, Z in branch G">
	<p>
		Can this be represented using a C-type array? Yes. But just because you can, doesn't mean you should. When you shouldn't, that's when things like list and map come into play. They are NOT wrappers around a hidden C-type array. Instead they use a completely different design...nodes.
	</p>

	<h1>Nodes: (Sometimes) A Better Way</h1>
	<h3>A Node?? What is that??</h3>

	<p>
		Here is a list. It's what you are going to be reading about for a while.
	</p>
	<img src="images/list.png" alt="a list with the contents A through D">
	<p>In this image, each blue square represents a node. A node has data. Each node in the image has A, B, C, or D as its data. A node also 'knows' about other nodes via connections. These connections keep the nodes in some specific order. The connections in the image are the black lines you see connecting the nodes together.</p>
	<p>When nodes are well designed, you can start anywhere in the list and move either direction. That means, each node has to know about the previous node, traditionally known as 'parent', and the next node traditionally known as 'child'. In the image above, the node containing B is the child of the node containing A and the node containing A is the parent of the node containing B.</p>
	<p>
		Examine the tree again.
	</p>

	<img src="images/tree.png" alt="A tree with root D, branches B and G, and leaves A, C in branch B, and E, Z in branch G">
	<p>
		In this image, each node has to 'know about' two children, traditionally called 'right child' and 'left child.' Therefore, the node containing D is the parent of the two nodes containing B and G. The parent of the node containing B is the node containing D. The parent of the node containing G is also the node containing D. 
	</p>
	<p>
		Compare the list and tree images. Notice that the right-most branch of the tree, the nodes containing D, G, and Z, looks just like a list. That's because a list is just a tree with no branches.&#128512 It should, then, be possible to create a well designed node that can be used to represent both a list and a tree. Ah...code re-use...that's a great thing! The code snippet below shows the code for a node that can hold characters and be used for lists and trees.&#128526
	</p>
	
	<p><pre><code class="C++">class Node{
private:
    char value;
    weak_ptr&lt;Node&gt; parent;
    shared_ptr&lt;Node&gt; left_child;
    shared_ptr&lt;Node&gt; right_child;
public:
    Node(char a_value);
    Node(char a_value, shared_ptr&lt;Node&gt; a_parent);
    char& operator * ();
};//end of Node class
</code></pre></p>
<p>
	This Node class has a constructor that has, as parameters, a value and the node that should be the parent. Inside this constructor is where the pointers are arranged to point from parent to child and from child to parent.
	</p>
<p> 
	Stop for a few minutes and think about deleting a bunch of linked nodes. Then answer the question, "Why is the parent pointer a <a href="https://studiofreya.com/cpp/cpp-smart-pointers-weak_ptr/">weak_ptr</a>?" Feel free to discuss this question and possible answers with other members of the class through direct conversation, or by some sort of posting. Googling won't be much help here.
</p>
<p>
	Now, having a node that can hold characters is OK, but yuck! Why can't it hold anything we want like the std::list class template we used last week? To do that, the Node class also has to be changed and become a node class template.</p> 
<p>
	<img src="images/stop.png" alt="a stop sign"> Go back and review <a href="../week04/index.html#template_description">last week's information about class templates</a> if you need to brush up.
</p>
<p> 
	I'm going to show you some code here...don't over think it. All that's going to happen is the <span class="file_name">char</span> type keyword is going to get replaced with a temporary placeholder. It's called <span class="file_name">T</span>. The first line of the code snippet below tells the compiler that Node is a class template, instead of a complete class, and the type placeholder is called <span class="file_name">T</span>. The  <span class="file_name">typename</span> keyword is just used to tell the compiler that  <span class="file_name">T</span> is actually a type, not a variable. All that's happened is one line of code is added so the compiler can understand what we are doing, and then all the <span class="file_name">char</span> type keywords are replaced with <span class="file_name">T</span>. Other than that, there are no changes.
</p>

	<p><pre><code class="C++">template&lt;typename T>
class Node{
private:
    T value;
    weak_ptr&lt;Node&gt; parent;
    shared_ptr&lt;Node&gt; left_child;
    shared_ptr&lt;Node&gt; right_child;
public:
    Node(T a_value);
    Node(T a_value, shared_ptr&lt;Node&gt; a_parent);
    T& operator * ();
};//end of Node class
</code></pre></p>
<p>
	This node class works and can encapsulate any type of data. This is a very important step in your path to becoming a programmer or software engineer. You are at a crossroads. You can embrace this type of abstract thinking and go on to be a wonderful programmer or software engineer. On the other hand, you can reject this type of abstract thinking and make little or no progress. Choose wisely. &#129488;
</p> 
<p>
	To continue learning about nodes, by themselves, they are pretty useless. Below is a simplistic, naive list class template. Notice, below, that the List class template has Node as a private, inner class. Because of this, no code anywhere else in any app can instantiate or use the encapsulated, Has_A Node class. Because the Node class template is completely encapsulated, it can be made much simpler than the previous code where Node was not encapsulated. Now its instance variables can be public and its operator can be deleted. It does keep the two constructors to help make instantiating Nodes easier.
</p>
<p>
	Using this design, each instance of List can instantiate and directly manipulate a Node any time the list is told to add an element, but nothing else can touch the List's Nodes. This is good.</p>
	<p>&#128512 Now the node won't need any <a href="https://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a> for getters, setters, operators, and the like.&#128512
</p>
<p>Compare the code for Node below with the Node code above.</p>
<p>
	There is a VERY important bit of code on the line right after the end of the encapsulated, Node inner class. <span class="file_name">shared_ptr&lt;Node&gt; root_node;</span>. This is a private instance variable of the List class template. It is a pointer to the Node instance that is the head, beginning, of the list. By convention, we are 
	referring to is as the root of the list. The root is equal to <span class="file_name">nullptr</span> for an empty list. 
</p>
<p>
	If you would like to, you can dowload the <a href="example_source/list.h" download>example list.h file</a>.
</p>

<p>
<pre><code>/*
* list.h
* Never use this code in production.&#128078; &#128078; 
*
* Use std::list.&#128077; 
*/

#ifndef list_h
#define list_h

#include &lt;functional&gt;

using std::shared_ptr;
using std::weak_ptr;

/*
* declaration of custom namespace, class template name, properties,
* constructors, operators, and member functions.
*/
namespace naive {

template&lt;typename T&gt;
/// This is a partial, naive implementation of a list-type container.
class List{
private:
    /*
     * Node is a private inner class so nothing other than an instance
     * of list can instantiate one. Node's properties are public so
     * instances of list can manipulate and access them directly.
    */
    class Node{
    public:
        T value;
        weak_ptr&lt;Node&gt; parent;
        shared_ptr&lt;Node&gt; left_child;
        shared_ptr&lt;Node&gt; right_child;
        //Node constructors
        Node(T a_value);
        Node(T a_value, shared_ptr&lt;Node&gt; a_parent);
    };//end of Node class
    shared_ptr&lt;Node&gt; root_node;
public:
    List();
    void push_back(T aValue);
    List&lt;T&gt; map(std::function&lt;T(T& a_value)&gt;mapping_function);
    /*
     * There are many more instance functions a fully functional list would need.
     * Take CSE232, Designing Data Structures, to learn more!!
     */
};//end of List class
}//end of custom namespace


using naive::List;

/*
 * List instance function implementations
 */

template&lt;typename T&gt;
/// Instantiates an empty List.
///
/// Complexity - O(n)
List&lt;T&gt;::List(){}

template&lt;typename T&gt;
/// Adds a value to the end of the list. The implementation was selected to illustrate how 
/// to move through a sequence of linked nodes. There are designs for List that allow 
/// push_back to be implemented more efficiently than this naive design.
/// @param aValue the value to add to the list
///
/// - Complexity: O(n)
void List&lt;T&gt;::push_back(T aValue){
    shared_ptr&lt;Node&gt;currentNode = root_node;
    shared_ptr&lt;Node&gt;node_to_add = shared_ptr&lt;Node&gt;(new Node(aValue));
   
    if(nullptr == currentNode){
        root_node = node_to_add;
        return;
    }
    while (nullptr != currentNode-&gt;right_child) {
        currentNode = currentNode-&gt;right_child;
    }
    currentNode-&gt;right_child = node_to_add;
    node_to_add-&gt;parent = currentNode;
}


template&lt;typename T&gt;
/// A non-destructive mapping instance methods.It applies the lambda function to
/// each value in the existing list and adds it to a list that is returned.
///
/// @param mapping_function the function to be applied to each value in the list
///
/// - Returns: a list that has as each of its values a modified version of each
/// value of this list
/// - Complexity: O(*n*) assuming that mapping_function has a complexity of O(*1*)
List&lt;T&gt; List&lt;T&gt;::map(std::function&lt;T(T& a_value)&gt;mapping_function){
    shared_ptr&lt;Node&gt;currentNode = root_node;
    //if this list is empty, its mapped version should be empty also
     if(nullptr == currentNode){
         return List&lt;T&gt;();//empty list
     }
    List&lt;T&gt; mapped_list;
     while (nullptr != currentNode) {
         T node_value = currentNode.get()-&gt;value;
         T mapped_value = mapping_function(node_value);
         mapped_list.push_back(mapped_value);
     }
    //return a copy of the list
    return mapped_list;
}

/*
 * Node instance function implementations
 */
template&lt;typename T&gt;
/// Value based constructor for a Node. For this constructor, the parent, left child,
/// and right child nodes are all null
/// @param a_value the value to be stored in the node
///
/// - Complexity: O(*1*)
List&lt;T&gt;::Node::Node(T a_value):value{a_value}{}


template&lt;typename T&gt;
/// Value and parent based constructor for a Node. For this constructor, the left 
/// and right child nodes are null
///
/// @param a_value the value to be stored in the node
/// @param a_parent a constant reference to the parent node of the node being constructed
///
/// - Complexity: O(*1*)
List&lt;T&gt;::Node::Node(T a_value, shared_ptr&lt;Node&gt; a_parent):value{a_value},parent{a_parent}{}

#endif /* list_h */
</code>
	</pre>
</p>

<p>
	To add a value to an empty list, use the list's <span class="file_name">push_back</span> instance function. You can find the code for the <span class="file_name">push_back</span> instance function above. There you can see that each time a value is to be added to a list, a node, <span class="file_name">node_to_add</span>, is created to encapsulate the value; then that node is added to the list. If the list is empty, <span class="file_name">node_to_add</span> is added to the list by setting the root node to be <span class="file_name">node_to_add</span>. Otherwise, the last node in the list is found, <span class="file_name">node_to_add</span> is set to be the last node's right child node, and <span class="file_name">node_to_add</span>'s parent is set to be the node that used to be the node at the end of the list.
</p>
<p>Below is an example of using this naive, incomplete list class template by using it to contain ints and then adding 3 ints to the list.
</p>
<p><pre><code class="C++">#include "list.h"

int main(int argc, const char * argv[]) {
    List&lt;int&gt; nums;
    nums.push_back(5);
    nums.push_back(7);
    nums.push_back(9);

    //make a new list that has all of the values doubled
    List&lt;int&gt; doubled = nums.map([](int an_int)-&gt;int{
        return an_int*2;
    });

    return 0;
}
</code></pre></p>

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</body>
</html>
