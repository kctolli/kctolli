<!-- uses https://highlightjs.org/
-->

<html>

<head>
	<link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
        <script type="text/javascript">
                 var codeType = "C++"
        </script>
        <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
        <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>
	

</head>

<body onload="fetchSource()">
<div class="hero-image">
  <div class="hero-text">
    <h1>CSE 220c: Week 01</h1>
    <p>Installation and Purpose</p> 
  </div>
</div>
	<h1>The Why of C++</h1>
	<h3>Some Background</h3>
	<p>Before and during the early 1970's, it was common to write operating systems in <a href="https://en.wikipedia.org/wiki/Assembly_language"
          target="_blank">assembly</a>, 
	a low-level programming language. The first implementation of the Unix operating system was written in assembly to run on the <a href="https://en.wikipedia.org/wiki/PDP-7"
          target="_blank">PDP-7</a> computer and later 
	was ported, by modifying the original assembly code, to the <a href="https://en.wikipedia.org/wiki/PDP-11"
          target="_blank">PDP-11</a>. Since writing and porting assembly for larger systems is difficult, first Ken Thompson 
	and later Dennis Richie decided to create languages to make this process easier. Thompson created the 
	<a href="https://en.wikipedia.org/wiki/B_(programming_language)"
          target="_blank">B</a> language that Richie used as a starting point when creating the earliest versions of
	<a href="https://en.wikipedia.org/wiki/C_(programming_language)#Early_developments"
          target="_blank">C</a>. By the end of 1973, the Unix kernel had been rewritten 
	completely in C, making it easier to port to new versions of hardware.</p>
	<p>C, then, was a language designed for writting operating systems, device drivers, and other types of systems. The patterns you use when you write C are those you would
		use if you were writing code for the PDP-11. Thankfully, the <a href="https://en.wikipedia.org/wiki/Portable_C_Compiler"
          target="_blank">portable C compiler</a> 
	led the way to making C available on multiple hardware systems that don't follow the PDP-11 hardware patterns while <a href="https://queue.acm.org/detail.cfm?id=3212479"
          target="_blank">maintaining the PDP-11 coding patterns</a>. Porting Unix is not an insignificant 
	task. In spite of this, the C language has made several flavors of Unix such as Solaris, MacOS, HP-UX, the BSD variants, and AIX possible. 
	Linux, a Unix-like system, is also written in C.</p>
	<p>In the late 1970's, <a href="http://www.stroustrup.com/hopl2.pdf"
          target="_blank">Bjarne Stroustrup was a graduate student</a>. He had been using a language called Simula to simulate parallel data flow in 
		computing systems. Amoung other things, Bjarne liked the way Simula allowed related functions to be grouped together into classes and that these classes could inherit properties 
		and functionality from base classes. Unfortunately for Bjarne, the Simula language had drawbacks as any language does. Simula struggled to scale. 
		It ran too large and too slow for Bjarne's project. Facing the collapse of his project, Bjarne switched languages to BCPL, a language he said was horrible. 
		As to how easy BCPL was to use, Bjarne said, "BCPL makes C look like a very high level language."
	</p>
	<p>
		After leaving the university with his PHD, Bjarne continued working on the problem he had faced. He eventually created C with Objects, and then 
		C++. His goal was to create a language that allowed the organizational goodies he liked from Simula and yet would scale like C.
	</p>
	<p>
		If you are interested in a career using C++, or just want to know it in depth, Stroustup's seminal book, The C++ Programming Language, <a href="https://www.amazon.com/Programming-Language-hardcover-4th/dp/0321958322/ref=sr_1_3?dchild=1&keywords=c%2B%2B+programming+language&qid=1600365132&sr=8-3"
          target="_blank">is available 
		in hardback, paperback and electronically</a>.
	</p>
	
	<h3>Python and C++ are Related</h3>
	<p>Take a look at Figure 1. It shows the ancestery of both C++ and Python. Since C is an ancestor of both C++ and Python you can expect to see some
	things in C++ that remind you of what you learned about coding in Python. C is not Python's only ancester. A very strong contributor to Python 
	is the <a href="https://en.wikipedia.org/wiki/Modula"
          target="_blank">Modula language</a>. Because of this ancestry, modules exist in Python that are somewhat 
	similar to classes in C++. Since Modula is not an ancestor of C++, C++ has no concept of a range and, as you will see, the syntax 
	and structure of for loops is different from what you learned for Python though the loop concepts remain the same.</p>

<figure>
  <img src="images/python_c++_lang_history.png" alt="Ancestor languages for Python, Modula 3, Pascal, ANSI C. Ancestor languages for C++, C++ 20, 
  	C++ 14, C++ 11, C++ 03, C++ 98, C++, C with classes. Ancestor languages of modern C, C 18, C 11, C 99, C 08. Ancestor of all three languages, 
  	C, B, BCPL, ALGOL 68, ALGOL 58, FORTRAN. The numbers after the language name indicate the year they were shipped.">
  <figcaption>Figure 1. - The anticedent languages for Python and C++ (Grady Booch and Bjarne Stroustrup).</figcaption>
</figure>
	<p>For a more complete understanding of the relationship between C and C++ read 
		<a href="https://pdfs.semanticscholar.org/c56c/95fc39e214b3fe91d82cbe9edd2e6ad5aac3.pdf"
          target="_blank">Stroustup's paper on the subject</a> written in 2002. There you will learn, among other things, that C++ is not a superset of C. The article does not, however, include changes made to both languages since 2002.</p>

<h1>Installations</h1>
	<h2>The IDE</h2>

	<h3>Windows</h3>
	<p>If it isn't already installed on your machine, start by following the instructions on the  <a href="https://visualstudio.microsoft.com/"
          target="_blank">installing Visual Studio 
		Community Edition page</a>. Do not install Visual Studio Code. Watch the video <a href="https://youtu.be/IsAoIqnNia4"
          target="_blank">How to Install Visual Studio 2019 for C++ Programming</a> to see how to complete the download, create your first project, 
		and then run it.
	</p>

	<h3>MacOS</h3>
		<p>If it isn't already installed on your machine, go to the  
			<a href="https://apps.apple.com/us/app/xcode/id497799835?mt=12"
          target="_blank">Apple app store download page for Xcode</a>. When you attempt to install, if you don't have the latest 
			version of MacOS, you may see a message saying you don't have a compatible MacOS version. If you see this message, update your OS to 
		the latest version.</p>
		<p>Follow the video tutorial <a href="https://youtu.be/HA-NahwEnyA"
          target="_blank">Compile C++ Using Xcode</a> to see how to create, compile, and run a C++ project 
		after launching Xcode.</p>

	

	<h3>Both</h3>
	<p>It is important for you to remember that you will want to make a DIFFERENT project for each task you are given. Do NOT create a single project 
		and think you can reuse it for all of your tasks. If you try this, you will regret it. Instead, create a directory into which you can save 
		all of your projects. That way you know where to look when you want to find an old project.
	</p>

<h2>Workflow</h2>
	<p>The work you do using these two tools will flow like this. Each time you are asked to do a task, create a directory named for the task. For example, 
		if you were asked for your task to write code that calculated loan payments, you could create a project called loan_pay_calc. 
		Each file you create for this task will be part of this project.</p>
	<p>If you follow this pattern for each assignment, you will reduce your workload.</p>
	<p>Do NOT create one project for the course and think that you can put the code for all of your tasks in it. If you ignore this advice and do this 
		anyway, your life will be harder, completing your tasks will take longer, and your code will be harder to understand. You don't need these 
		self-inflicted barriers to your learning.<br><br> MAKE A SEPERATE PROJECT FOR EACH TASK!!!!
	</p>

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</body>
</html>